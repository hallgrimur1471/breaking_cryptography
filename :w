"""
The CBC padding oracle

b'YELLOW SUBMARIN\x01'
b'ASDFASDFASDFASDF'

b'ASDFASDFASDFESDF'
b'QWERTEWRTEWRYTE\x01'


b'YELLOW SUBMARI\x02\x02'
b'ASDFASDFASDFASDF'

b'ASDFASDFASDFESDF'
b'QWERTEWRTEWRYTE\x01'
"""

import logging
import base64
import random

import drvn.cryptography.aes as aes
import drvn.cryptography.utils as utils


def run_challenge():
    victim_api = VictimAPI()
    ciphertext = victim_api.sniff_ciphertext()

    ciphertexts = set()
    logging.info("Sniffing for ciphertexts ...")
    for _ in range(100):
        ciphertext = victim_api.sniff_ciphertext()
        ciphertexts.add(bytes(ciphertext))
    print(f"{len(ciphertexts)=}")

    for ciphertext in ciphertexts:
        if aes.detect_mode(ciphertext) == "ecb":
            raise RuntimeError(
                "Can not decrypt ciphertext using CBC padding oracle "
                + "because ciphertext was encrypted in ECB mode"
            )

    return

    padding_oracle = victim_api.consume
    plaintext = aes.decrypt_cbc_ciphertext_using_padding_oracle(
        ciphertext, padding_oracle
    )

    logging.info(
        f"\nSniffed ciphertext:\n{ciphertext.hex()}\n"
        + f"was decrypted using {victim_api.num_consume_calls} calls to "
        + f"the padding oracle, the first block of plaintext is unknown (?) so the resulting plaintext is:\n{plaintext}"
    )


# pylint: disable=no-self-use
class VictimAPI:
    def __init__(self):
        self.num_consume_calls = 0

        self._key = aes.generate_random_aes_key()
        self._iv = aes.generate_random_aes_key()

        self._secrets = [
            base64.b64decode(txt)
            for txt in [
                "MDAwMDAwTm93IHRoYXQgdGhlIHBhcnR5IGlzIGp1bXBpbmc=",
                "MDAwMDAxV2l0aCB0aGUgYmFzcyBraWNrZWQgaW4gYW5kIHRoZSBWZWdhJ3MgYX"
                + "JlIHB1bXBpbic=",
                "MDAwMDAyUXVpY2sgdG8gdGhlIHBvaW50LCB0byB0aGUgcG9pbnQsIG5vIGZha2"
                + "luZw==",
                "MDAwMDAzQ29va2luZyBNQydzIGxpa2UgYSBwb3VuZCBvZiBiYWNvbg==",
                "MDAwMDA0QnVybmluZyAnZW0sIGlmIHlvdSBhaW4ndCBxdWljayBhbmQgbmltYm"
                + "xl",
                "MDAwMDA1SSBnbyBjcmF6eSB3aGVuIEkgaGVhciBhIGN5bWJhbA==",
                "MDAwMDA2QW5kIGEgaGlnaCBoYXQgd2l0aCBhIHNvdXBlZCB1cCB0ZW1wbw==",
                "MDAwMDA3SSdtIG9uIGEgcm9sbCwgaXQncyB0aW1lIHRvIGdvIHNvbG8=",
                "MDAwMDA4b2xsaW4nIGluIG15IGZpdmUgcG9pbnQgb2g=",
                "MDAwMDA5aXRoIG15IHJhZy10b3AgZG93biBzbyBteSBoYWlyIGNhbiBibG93",
            ]
        ]

    def sniff_ciphertext(self):
        random_secret = random.choice(self._secrets)
        ciphertext = aes.encrypt_cbc(
            random_secret, self._key, self._iv, add_padding=True
        )
        return ciphertext

    def consume(self, ciphertext):
        """
        Returns true if resulting plaintext has a valid padding, false otherwise
        """
        self.num_consume_calls += 1
        plaintext_padded = aes.decrypt_cbc(
            ciphertext, self._key, self._iv, remove_padding=False
        )
        return utils.is_valid_pkcs7_padding(plaintext_padded)

    # TODO: remove
    def decrypt(self, ciphertext):
        plaintext_padded = aes.decrypt_cbc(
            ciphertext, self._key, self._iv, remove_padding=False
        )
        return plaintext_padded
